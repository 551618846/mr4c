/**
  * Copyright 2014 Google Inc. All rights reserved.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  * 
  *     http://www.apache.org/licenses/LICENSE-2.0
  * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
*/

#include <cmath>
#include <ostream>
#include <stdexcept>
#include <iostream>

#include "coord/coord_api.h"
#include "util/util_api.h"

namespace MR4C {


class ImageBoxImpl {

	friend class ImageBox;

	private :

		int m_x1;
		int m_y1;
		int m_x2;
		int m_y2;
		int m_width;
		int m_height;
		BoundingBox m_bound;

		ImageBoxImpl() {
			m_width = 0;
			m_height = 0;
			m_x1 = 0;
			m_y1 = 0;
			m_x2 = 0;
			m_y2 = 0;
		}

		ImageBoxImpl(
			int width,
			int height,
			const BoundingBox& bound,
			int x,
			int y
		) {
			m_width = width;
			m_height = height;
			m_bound = bound;
			m_x1 = x;
			m_y1 = y;
			m_x2 = x + width;
			m_y2 = y + height;
			validateBox();
		}
			
		ImageBoxImpl(const ImageBox& box) {
			initFrom(box);
		}

		void initFrom(const ImageBox& box) {
			m_width = box.getWidth();
			m_height = box.getHeight();
			m_bound = box.getBound();
			m_x1 = box.getX1();
			m_y1 = box.getY1();
			m_x2 = box.getX2();
			m_y2 = box.getY2();
		}

		void validateBox() {
			if ( m_width <= 0 ) {
				MR4C_THROW(std::invalid_argument, "ImageBox width is zero or negative: " << m_width);
			}
			if ( m_height <= 0 ) {
				MR4C_THROW(std::invalid_argument, "ImageBox height is zero or negative" << m_height);
			}
			if ( m_x1 < 0 ) {
				MR4C_THROW(std::invalid_argument, "ImageBox x origin is negative" << m_x1);
			}
			if ( m_y1 < 0 ) {
				MR4C_THROW(std::invalid_argument, "ImageBox y origin is negative" << m_y1);
			}

		}

		int getWidth() const {
			return m_width;
		}

		int getHeight() const {
			return m_height;
		}

		int getX1() const {
			return m_x1;
		}

		int getY1() const {
			return m_y1;
		}

		int getX2() const {
			return m_x2;
		}

		int getY2() const {
			return m_y2;
		}

		BoundingBox getBound() const {
			return m_bound;
		}

		// this uses a different coordinate system than the bound was generated by, resulting in the bounds not lining up properly
		ImageBox windowOld(const BoundingBox& bound) const {

			NormMercCoord nw = bound.getNWCoordAsNormMerc();
			NormMercCoord se = bound.getSECoordAsNormMerc();
			NormMercCoord thisNW = m_bound.getNWCoordAsNormMerc();

			double xscale = m_width / m_bound.dx();
			double yscale = m_height / m_bound.dy();

			int x1 = (int) round( m_x1 + xscale * ( nw.getX() - thisNW.getX() ) );
			int y1 = (int) round( m_y1 + yscale * ( nw.getY() - thisNW.getY() ) );

			int width = (int) round( xscale * ( se.getX() - nw.getX() ) );
			int height = (int) round( yscale * ( se.getY() - nw.getY() ) );

			return ImageBox(
				width,
				height,
				bound,
				x1,
				y1
			);
		}

		ImageBox window(const BoundingBox& bound) const {

			EastNorthCoord nw = bound.getNWCoordAsEastNorth();
			EastNorthCoord se = bound.getSECoordAsEastNorth();
			EastNorthCoord thisNW = m_bound.getNWCoordAsEastNorth();

			double xscale = m_width / m_bound.dE();
			double yscale = m_height / m_bound.dN();

			int x1 = (int) round( m_x1 + xscale * ( nw.getEast() - thisNW.getEast() ) );
			int y1 = (int) round( m_y1 - yscale * ( nw.getNorth() - thisNW.getNorth() ) );

			int width = (int) round( xscale * ( se.getEast() - nw.getEast() ) );
			int height = (int) round( yscale * ( nw.getNorth() - se.getNorth() ) );

			return ImageBox(
				width,
				height,
				bound,
				x1,
				y1
			);
		}

		std::string str() const {
			MR4C_RETURN_STRING(
				"x1 = " << m_x1 << "; " <<
				"y1 = " << m_y1 << "; " <<
				"x2 = " << m_x2 << "; " <<
				"y2 = " << m_y2 << "; " <<
				"width = " << m_width << "; " <<
				"height = " << m_height << "; " <<
				"bound = " << m_bound
			);
		}


		~ImageBoxImpl() {}

		bool operator==(const ImageBoxImpl& box) const {
			if ( m_x1!=box.m_x1 ) return false;
			if ( m_y1!=box.m_y1 ) return false;
			if ( m_x2!=box.m_x2 ) return false;
			if ( m_y2!=box.m_y2 ) return false;
			if ( m_width!=box.m_width ) return false;
			if ( m_height!=box.m_height ) return false;
			if ( m_bound!=box.m_bound ) return false;
			return true;
		}

};

ImageBox::ImageBox() {
	m_impl = new ImageBoxImpl();
}

ImageBox::ImageBox(
	int width,
	int height,
	const BoundingBox& bound,
	int x,
	int y
) {
	m_impl = new ImageBoxImpl(width, height, bound, x, y);
}

ImageBox::ImageBox(const ImageBox& box) {
	m_impl = new ImageBoxImpl(box);
}

int ImageBox::getWidth() const {
	return m_impl->getWidth();
}

int ImageBox::getHeight() const {
	return m_impl->getHeight();
}

int ImageBox::getX1() const {
	return m_impl->getX1();
}

int ImageBox::getY1() const {
	return m_impl->getY1();
}

int ImageBox::getX2() const {
	return m_impl->getX2();
}

int ImageBox::getY2() const {
	return m_impl->getY2();
}

BoundingBox ImageBox::getBound() const {
	return m_impl->getBound();
}

ImageBox ImageBox::window(const BoundingBox& bound) const {
	return m_impl->window(bound);
}

std::string ImageBox::str() const {
	return m_impl->str();
}

ImageBox::~ImageBox() {
	delete m_impl;
}

ImageBox& ImageBox::operator=(const ImageBox& box) {
	m_impl->initFrom(box);
	return *this;
}

bool ImageBox::operator==(const ImageBox& box) const {
	return *m_impl==*box.m_impl;
}

bool ImageBox::operator!=(const ImageBox& box) const {
	return !operator==(box);
}

std::ostream& operator<<(std::ostream& os, const ImageBox& box) {
	os << box.str();
	return os;
}


}
